{"version":3,"sources":["components/Todo.js","components/Form.js","components/FilterButton.js","App.js","index.js"],"names":["Todo","props","useState","setEditing","newName","setNewName","useSpring","opacity","from","id","name","pessoal","Form","setName","onSubmit","e","preventDefault","addTask","className","htmlFor","type","autoComplete","value","onChange","target","placeholder","maxLength","FilterButton","aria-pressed","isPressed","onClick","setFilter","FILTER_MAP","Tudo","Trabalho","task","Pessoal","FILTER_NAMES","Object","keys","App","tasks","setTasks","filter","editTask","editedTaskList","map","toggleTaskPessoal","updatedTasks","console","log","deleteTask","remainingTasks","taskList","key","filterList","tasksNoun","length","headingText","newTask","nanoid","role","aria-labelledby","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.48289a8b.chunk.js","sourcesContent":["import React, {useState} from 'react';\r\n\r\nimport {RiCloseCircleLine} from 'react-icons/ri'\r\nimport {TiEdit} from 'react-icons/ti'\r\nimport { BsCheckCircle } from 'react-icons/bs';\r\nimport { BsDashCircleFill } from 'react-icons/bs';\r\n\r\nimport {useSpring, animated} from 'react-spring'\r\n\r\n\r\nexport default function Todo(props) {\r\n\r\n    const [isEditing, setEditing] = useState(false);\r\n    const [newName, setNewName] = useState('');\r\n    const pop = useSpring({opacity: 1, from: {opacity: 0}})\r\n\r\n    function handleChange(e) {\r\n      setNewName(e.target.value);\r\n    }\r\n\r\n    function handleSubmit(e) {\r\n      e.preventDefault();\r\n      props.editTask(props.id, newName);\r\n      setNewName(\"\");\r\n      setEditing(false);\r\n    }\r\n\r\n    //criamos duas UIs diferentes, uma para a visualização padrão da tarefa e uma para a edição da tarefa\r\n    const editingTemplate = (\r\n      <form className=\"stack-small\" onSubmit={handleSubmit}>\r\n        <div className=\"form-group\">\r\n          <label className=\"todo-label\" htmlFor={props.id}>\r\n            Editando a tarefa {props.name}\r\n          </label>\r\n          <input \r\n            id={props.id} \r\n            className=\"todo-text\" \r\n            type=\"text\" \r\n            value={newName}\r\n            onChange={handleChange}\r\n          />\r\n        </div>\r\n        <div className=\"icon-group\">\r\n          <button className=\"tooltip\"><BsDashCircleFill className=\"btn-icon cancel\" onClick={() => setEditing(false)}  /><span class=\"tooltiptext\">Cancelar<span className=\"visually-hidden\">edição da tarefa {props.name}</span></span></button>          \r\n          <button className=\"tooltip\" type=\"submit\"><BsCheckCircle  className=\"btn-icon save\" /><span class=\"tooltiptext\">Confirmar<span className=\"visually-hidden\">edição da tarefa {props.name}</span></span></button>          \r\n        </div>\r\n      </form>\r\n    );\r\n    const viewTemplate = (\r\n      <div className=\"stack-small\">\r\n        <div className=\"c-cb\">          \r\n            <input\r\n              id={props.id}\r\n              type=\"checkbox\"\r\n              defaultChecked={props.pessoal}\r\n              //quando houver alteração no checkbox a prop 'toggleTaskPessoal' será acionada e receberá o 'id' da tarefa que alterou o estado do checkbox\r\n              onChange={() => props.toggleTaskPessoal(props.id)}\r\n            />\r\n            <label className=\"todo-label\" htmlFor={props.id}>\r\n              {props.name}\r\n            </label>\r\n        </div>\r\n          <div className=\"btn-group icon-group\">\r\n            <button className=\"tooltip\"><TiEdit className=\"btn-icon edit\" onClick={() => setEditing(true)}/><span class=\"tooltiptext\" style={{top: \"-30px\"}}>Editar<span className=\"visually-hidden\">{props.name}</span></span></button>            \r\n            <button className=\"tooltip\"><RiCloseCircleLine className=\"btn-icon delete\" onClick={() => props.deleteTask(props.id)}/><span class=\"tooltiptext\" style={{top: \"-30px\"}}>Remover<span className=\"visually-hidden\">{props.name}</span></span></button>            \r\n          </div>\r\n      </div>\r\n    );\r\n\r\n    return (\r\n      //utilizamos o conditional rendering do jsx para indicarmos qual UI queremos que seja exibida. se o valor de 'isEditing' for true então a UI de edição de task será exibida, do contrário a UI de visualização padrão será exibida      \r\n      <animated.div style={pop}><li className=\"todo\">{isEditing ? editingTemplate : viewTemplate}</li></animated.div>              \r\n    );\r\n}","import React, {useState} from 'react';\r\n\r\n\r\nexport default function Form(props) {\r\n\r\n    const [name, setName] = useState(\"\");\r\n\r\n    //função ativada quando o usuário digita no campo input\r\n    //essa função será usada para alterar o state 'name' que, por sua vez, é o estado responsável pelo state do input\r\n    function handleChange(e) {\r\n        setName(e.target.value)\r\n    }\r\n\r\n    //função acionada quando o usuário clica no botão 'ADD'\r\n    function handleSubmit(e) {\r\n        e.preventDefault();\r\n        props.addTask(name);\r\n        setName(\"\");\r\n    }\r\n\r\n    return(\r\n        <form onSubmit={handleSubmit}>\r\n        <h2 className=\"label-wrapper\">\r\n          <label htmlFor=\"new-todo-input\" className=\"label__lg visually-hidden\">\r\n            Insira uma nova tarefa abaixo.\r\n          </label>\r\n        </h2>\r\n        <input\r\n          type=\"text\"\r\n          id=\"new-todo-input\"\r\n          className=\"input input__lg\"\r\n          name=\"text\"\r\n          autoComplete=\"off\"\r\n          value={name}\r\n          onChange={handleChange}\r\n          placeholder=\"Insira uma nova tarefa\"\r\n          maxLength=\"100\"//limita o input à 100 caracteres\r\n        />\r\n        <button type=\"submit\" className=\"btn btn__primary btn__lg\">\r\n          Adicionar tarefa\r\n        </button>\r\n      </form>\r\n    )\r\n}","import React from 'react';\r\n\r\nexport default function FilterButton(props) {\r\n    return (\r\n        <button \r\n          type=\"button\" \r\n          className=\"btn toggle-btn\" \r\n          aria-pressed={props.isPressed}\r\n          onClick={() => props.setFilter(props.name)}\r\n        >\r\n          <span className=\"visually-hidden\">Exiba </span>\r\n          <span>{props.name}</span>\r\n          <span className=\"visually-hidden\"> tarefas</span>\r\n        </button>        \r\n    )\r\n}","import React, {useState} from 'react';\r\nimport {nanoid} from 'nanoid';\r\n\r\nimport Todo from './components/Todo';\r\nimport Form from './components/Form';\r\nimport FilterButton from './components/FilterButton';\r\n\r\n\r\n//criamos um objeto no qual cada valor é uma função. esses serão nossos filters buttons\r\nconst FILTER_MAP = {\r\n  Tudo: () => true,\r\n  Trabalho: task => !task.pessoal,\r\n  Pessoal: task => task.pessoal,\r\n};\r\n\r\n//criamos uma variável que coletará um array de FILTER_NAMES utilizando as keys do FILTER_MAP\r\nconst FILTER_NAMES = Object.keys(FILTER_MAP);\r\n\r\n\r\nfunction App(props) {\r\n\r\n  const [tasks, setTasks] = useState(props.tasks);\r\n  const [filter, setFilter] = useState('Tudo');\r\n\r\n  //a função addTask recebe um 'name', que é o input do user, monta um objeto com id, name, e pessoal, em seguida chama a função 'setTask', utiliza o spred operator para copiar o array de tasks existente e adiciona a new task nesse array.\r\n  //para não haver conflito de id, utilizei a lib 'nanoid' para gerar os ids das tasks\r\n  function addTask(name) {\r\n    const newTask = {id: \"todo-\" + nanoid(), name: name, pessoal: false};\r\n    setTasks([...tasks, newTask]);\r\n    console.log(tasks)\r\n  }\r\n\r\n  //a função editTask espera receber o id e um novo valor de name da task q a invocou. \r\n  function editTask(id, newName) {\r\n    //a variável editedTaskList usa o map para iterar pelo array de tasks executando a função que compara o id recebido pela função com o id das tasks, se houver um id que combine com o recebido então é criado um novo objeto dessa task com os mesmos atributos excetuando apenas o 'name', que rebe um novo valor. Atualizamos o estado do array de tasks utilizando a variável editedTaskList.\r\n    const editedTaskList = tasks.map(task => {\r\n      //se o id recebido combinar com algum id do array...\r\n      if(id === task.id) {\r\n        return {...task, name: newName}\r\n      }\r\n      return task;\r\n    })\r\n    setTasks(editedTaskList);\r\n  }\r\n\r\n  function toggleTaskPessoal(id) {\r\n    const updatedTasks = tasks.map(task => {\r\n      //se essa task tiver o mesmo id da task editada\r\n      if(id === task.id) {\r\n        //usamos o spred para criar um novo objeto 'task' no qual a prop 'pessoal' foi invertida\r\n        return {...task, pessoal: !task.pessoal}\r\n      }\r\n      return task;\r\n    });\r\n    setTasks(updatedTasks);\r\n    console.log(tasks[0])\r\n  }\r\n\r\n  function deleteTask(id) {\r\n    //console.log(id);\r\n    // a variável 'remainingTasks' vai receber um array de tasks, utilizando o filter, no qual o id da task que chamou a função não existe e, consequentemente, a task em si também não. Atualizamos o setTasks com essa variável.\r\n    const remainingTasks = tasks.filter(task => id !== task.id);\r\n    setTasks(remainingTasks);\r\n  }\r\n\r\n  const taskList = tasks\r\n    //ao renderizar a taskList primeiro devemos fazer um filter para que sejam exibidas apenas as tasks selecionadas pelo FILTER_MAP \r\n    .filter(FILTER_MAP[filter])\r\n    .map(task => (\r\n    <Todo \r\n      id={task.id} \r\n      name={task.name} \r\n      pessoal={task.pessoal} \r\n      key={task.id} \r\n      toggleTaskPessoal={toggleTaskPessoal}\r\n      deleteTask={deleteTask}\r\n      editTask={editTask}\r\n    />\r\n  ));\r\n\r\n  const filterList = FILTER_NAMES.map(name => (\r\n    <FilterButton \r\n      key={name} \r\n      name={name}\r\n      isPressed={name === filter}\r\n      setFilter={setFilter}\r\n    />\r\n  ));\r\n\r\n  //aqui criamos uma variável que conta os elementos do nosso array de tasks e recebe a string 'tasks' se o array possuir mais de 1 elemento ou a string 'task' ou a string 'task' se possuir apenas 1.\r\n  //e outra variável que imprime a quantidade de tasks restantes utilizando também a variável acima\r\n  const tasksNoun = taskList.length > 1 ? 'tarefas restantes' : 'tarefa restante';\r\n  const headingText = `${taskList.length} ${tasksNoun}`;\r\n\r\n  \r\n\r\n  return (\r\n    <div className=\"todoapp stack-large\">\r\n      <h1>Lista de Tarefas</h1>\r\n      <Form addTask={addTask} />\r\n      <div className=\"filters btn-group stack-exception\">\r\n        {filterList}\r\n      </div>\r\n      <h2 id=\"list-heading\">\r\n        {headingText}\r\n      </h2>\r\n      <h4>Marque a caixa de texto em caso de tarefas pessoais.</h4>\r\n      \r\n      <ul\r\n        role=\"list\"\r\n        className=\"todo-list stack-large stack-exception\"\r\n        aria-labelledby=\"list-heading\"\r\n      >  \r\n           \r\n        {taskList}  \r\n      </ul>      \r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\n\r\nconst DATA = [\r\n  { id: \"todo-0\", name: \"Estudar ReactJs\", pessoal: true },\r\n]\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App tasks={DATA} />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n"],"sourceRoot":""}